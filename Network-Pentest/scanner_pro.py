Archivo,Funci√≥n Principal,Cu√°ndo usarlo
scanner_pro.py,An√°lisis Profundo,"Auditor√≠as detalladas, reportes de vulnerabilidades espec√≠ficos y detecci√≥n de OS."
scanner_turbo.py,Velocidad Nmap,Reconocimiento r√°pido de activos en redes grandes o respuestas ante incidentes.
generar_reporte.py,Motor PDF,La librer√≠a que ambos usan para crear tus entregables.
import requests
import socket
from scapy.all import *
from generar_reporte import crear_pdf
from datetime import datetime

# CONFIGURACI√ìN
VT_API_KEY = "15fb68355c222b4c34ff360792db6c4c361ae7d6e2d47fabe83acf46920c173f"

# DICCIONARIO DE INTELIGENCIA DE AMENAZAS
THREAT_MAP = {
    21: {"n": "FTP", "a": "Fuerza Bruta / Sniffing", "r": "ALTO", "d": "Tr√°fico no cifrado. Riesgo de robo de credenciales."},
    22: {"n": "SSH", "a": "Fuerza Bruta / Exploits", "r": "MEDIO", "d": "Acceso remoto. Seguro si est√° actualizado y con llaves."},
    23: {"n": "Telnet", "a": "Intercepci√≥n total", "r": "CR√çTICO", "d": "Protocolo inseguro. Todo viaja en texto plano."},
    53: {"n": "DNS", "a": "Envenenamiento / DoS", "r": "ALTO", "d": "Puede ser usado para redirigir tr√°fico a sitios falsos."},
    80: {"n": "HTTP", "a": "SQLi / XSS / Inyecci√≥n", "r": "CR√çTICO", "d": "Servidor web sin cifrar. Puerta de entrada principal."},
    110: {"n": "POP3", "a": "Robo de correos", "r": "ALTO", "d": "Protocolo de correo antiguo y sin cifrar."},
    443: {"n": "HTTPS", "a": "Ataques SSL/TLS", "r": "BAJO", "d": "Cifrado. El riesgo suele estar en la aplicaci√≥n, no en el puerto."},
    445: {"n": "SMB", "a": "Ransomware / WannaCry", "r": "CR√çTICO", "d": "Compartici√≥n de archivos. Muy vulnerable en redes internas."},
    3306: {"n": "MySQL", "a": "Exfiltraci√≥n de Datos", "r": "CR√çTICO", "d": "Base de datos expuesta. Riesgo total de p√©rdida de informaci√≥n."},
    3389: {"n": "RDP", "a": "BlueKeep / Fuerza Bruta", "r": "CR√çTICO", "d": "Escritorio remoto. Objetivo #1 para ransomware."}
}

def obtener_geolocalizacion(ip):
    try:
        res = requests.get(f"http://ip-api.com/json/{ip}").json()
        if res['status'] == 'success':
            return f"üìç UBICACI√ìN: {res['city']}, {res['country']} | ISP: {res['isp']}"
        return "üìç UBICACI√ìN: No disponible (IP Privada o Local)"
    except: return "Error en Geo-IP"

def consultar_virustotal(ip):
    url = f"https://www.virustotal.com/api/v3/ip_addresses/{ip}"
    headers = {"x-apikey": VT_API_KEY}
    try:
        response = requests.get(url, headers=headers)
        if response.status_code == 200:
            s = response.json()['data']['attributes']['last_analysis_stats']
            return f"‚ò£Ô∏è REPUTACI√ìN: Maliciosos: {s['malicious']} | Sospechosos: {s['suspicious']} | Limpios: {s['harmless']}"
        return "‚ò£Ô∏è REPUTACI√ìN: Sin datos en VirusTotal"
    except: return "Error en VirusTotal"

def obtener_banner(ip, puerto):
    try:
        s = socket.socket()
        s.settimeout(1)
        s.connect((ip, puerto))
        banner = s.recv(1024).decode().strip()
        s.close()
        return banner if banner else "Servicio detectado (Banner oculto)"
    except: return "No se pudo extraer versi√≥n"

# --- INTERFAZ DE USUARIO ---
print("\n" + "="*70)
print("üõ°Ô∏è  SOC THREAT ANALYST TOOL v5.0 - INVESTIGACI√ìN INTEGRAL")
print("="*70)
objetivo = input("üåê Ingrese la IP a auditar: ")
print("\n[*] Iniciando fase de Reconocimiento y Threat Intelligence...")

# 1. Recolecci√≥n de Inteligencia
geo = obtener_geolocalizacion(objetivo)
reputacion = consultar_virustotal(objetivo)
print(geo)
print(reputacion)

resumen_reporte = f"REPORTE DE AUDITOR√çA SOC - {objetivo}\n"
resumen_reporte += f"FECHA: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n"
resumen_reporte += f"{geo}\n{reputacion}\n" + ("="*70) + "\n"

# 2. Escaneo de Puertos y An√°lisis de Vulnerabilidades
os_identificado = False
print(f"[*] Escaneando puertos principales (1-1024) y analizando riesgos...")

for puerto in range(1, 1025):
    paquete = IP(dst=objetivo)/TCP(dport=puerto, flags="S")
    respuesta = sr1(paquete, timeout=0.5, verbose=False)
    
    if respuesta and respuesta.haslayer(TCP) and respuesta.getlayer(TCP).flags == 0x12:
        # Detecci√≥n de OS por TTL (solo la primera vez)
        if not os_identificado:
            ttl = respuesta.getlayer(IP).ttl
            os_p = "Linux" if ttl <= 64 else "Windows" if ttl <= 128 else "Dispositivo de Red"
            info_os = f"üíª OS PROBABLE: {os_p} (TTL: {ttl})\n"
            print(f"[*] {info_os}")
            resumen_reporte += info_os + ("-"*70) + "\n"
            os_identificado = True

        # An√°lisis de Amenaza
        banner = obtener_banner(objetivo, puerto)
        if puerto in THREAT_MAP:
            info = THREAT_MAP[puerto]
            linea_consola = f"[!] PUERTO {puerto} ({info['n']}) ABIERTO - RIESGO: {info['r']}"
            detalle_pdf = f"PUERTO: {puerto} ({info['n']})\nRIESGO: {info['r']}\nATAQUE COM√öN: {info['a']}\nBANNER: {banner}\nDESCRIPCI√ìN: {info['d']}\n"
        else:
            linea_consola = f"[!] PUERTO {puerto} ABIERTO - Banner: {banner}"
            detalle_pdf = f"PUERTO: {puerto}\nRIESGO: NO CLASIFICADO\nBANNER: {banner}\n"

        print(linea_consola)
        resumen_reporte += detalle_pdf + ("."*40) + "\n"

# 3. Finalizaci√≥n y PDF
nombre_pdf = f"Investigacion_SOC_{objetivo.replace('.', '_')}.pdf"
crear_pdf(nombre_pdf, resumen_reporte)
print("\n" + "="*70)
print(f"‚úÖ AN√ÅLISIS COMPLETADO. REPORTE GENERADO: {nombre_pdf}")
print("="*70 + "\n")